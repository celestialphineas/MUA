# MUA解释器设计准则

## 对象

### 原子对象

- 数（不区分整数和浮点数）
- 布尔
- 字（word，不包含空白字符的字符串）

### 复合对象

- 表

### 操作对象

- 内建操作
- 自定义操作

操作一定会被作为一个表的头部，每个操作都应当有一个可以访问到的namespace，指定了接受的操作数数目和一系列操作。

## 赋值

赋值操作`make`不对第二个操作数做检查和估值，即保持第二个操作数的结构。`make`的作用是延迟/惰性赋值(set delayed).

为实现即时赋值(set immediate)，引入`eval`操作对后面的表达式做估值。

## Namespace

每个作用域scope都是一个命名空间namespace，namespace可以公有或私有，每个列表创建时，都会生成一个缺省作用域，但是权限默认为私有。

每个namespace应包含其父namespace指针和一个hash表用于寄放对象。

Global作用域和每个列表内都是一个namespace

## 表达式

所有MUA语句都是表达式，所有表达式都是一个表。语句的执行即表达式（表）的化简，化简的结果将被替代这个表。

## 操作（函数）

0. 操作即表的第零个元素，或“头部”(head)。
1. 操作指定了自己的操作数数目，不支持重载。操作参数信息的检查发生在构建表达式列表时。
2. 列表`[]`是操作，是MUA中唯一一个允许变长操作数的操作，在构建表达式列表时，列表将会被转换为一个头部为`list`的表。
3. 可以通过列表去生成一个操作，我们将其称作“操作化”——满足某些特定条件的列表可以作为操作使用。
4. 内部实现中，每个操作除了接受操作数和操作表外，还需要知道当前作用域/命名空间。
5. 内建操作将尽可能保证正交性，从而使类型检查不必要。

## 操作化

满足以下条件的列表可以操作化：

1. 列表包含且仅包含两个子列表
2. 第一个子列表为一个word列表，包含了所有参数名称的声明
3. 第二个子列表为一系列表达式

操作化某对象时会发生以下事件：

1. 第一个列表中的所有word会被注册到列表的命名空间作为对象。
2. 生成的操作对象的命名空间就将会是列表的。

## 评述：列表的特殊地位

尽管所有MUA对象不是原子就是表，列表在所有对象中具有特殊地位：

1. 尽管所有操作都应当具有一个namespace指针，出于封装和操作化考虑，列表有一个属于自己的namespace.
2. 一些列表是可以操作化的。

## 解决原MUA设计的歧义性

个人觉得在MUA中引入中缀表达式是不优雅的设计，或至少在不改变语言其他部分的情况下不优雅。引入中缀表达式，空白字符和分割字符变得职能过重。以下举出几个语言的例子，它们实现了中缀表达式，但都有相对应的语法特性保证不会引起歧义。

Mathematica实现中缀表达式，但是它的表达式都是有括号边界的，参数之间由逗号分割，从而不会引起歧义。

Shell的中缀表达式只对部分命令有效，而且是作为参数传入的，由命令解决表达式估值。Shell本身并不会对中缀表达式做任何转换。更重要的是，Shell一般不会允许命令的嵌套，如果需要嵌套，有一套特殊的形式可供使用。

MUA目前的设计无法避免中缀的歧义。如果中缀转换放在前端，做成上下文无关的，那么势必有一些本来没有歧义的表达式将无法计算。比如`make "a +1`，它有两种解释，`make add "a 1`或`make "a (+1)`，很显然，后面一个才应该是正确的解释。而做成上下文相关的，解释器编写难度将非常巨大。

按照要求上所述，只实现数字之间的运算，那么`make "a "a+1`是不被允许的，中缀只参与诸如`1 + 1`这样的常量计算。如此看来，这个中缀引入得未免有些无聊，且二义性问题依旧没有解决。例如`[1 -1]`具有二义性，`[mul 1 1]`是一种可能的解释，列表`[1 (-1)]`是另一种可能的解释。

在这一MUA解释器实现中，`[1 -1]`解释为`[1 (-1)]`，`[1-1]`解释为`[mul 1 1]`，`[1 - 1]`解释为`[mul 1 1]`。

MUA应当是词法作用域的。

如果将`ift`、`iff`视作`test`表达式的一部分，那么由于MUA参数必须是确定好的，`ift`和`iff`必须同时存在，或`test`函数需要比较巧妙的设计。如果视作分离的语句，则违背了这一MUA实现的基本原则。

export
exportglobal

main中清除trace stack
添加lisp和mua形式切换开关

与其set delay不如set和hold，list单独对待。

为了规避歧义，但凡正负号和后面连到一起而前面也没有负号

性能优化余地：

- 部分`List`容器遍历的方式。
- 一些`Token`使用常量以减省开销。
- 部分构造函数设计不够合理，有额外不合理开销。
- 有些单例，不是好主意……我觉得MUA有并发潜质。
- 其实这个东西应该用C或C++重写（但是不回收内存是巨坑，需要精心设计）。

给`make`添加按命名空间赋值的功能
修订`clear`
添加打印整数的功能
冒号字符